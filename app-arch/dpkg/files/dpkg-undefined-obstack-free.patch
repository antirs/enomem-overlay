--- a/lib/compat/obstack.c	2025-07-02 06:39:26.424348569 +0000
+++ b/lib/compat/obstack.c	2025-07-02 06:37:40.336350888 +0000
@@ -356,6 +356,36 @@ __obstack_free (struct obstack *h, void
     abort ();
 }
 
+void
+_obstack_free (struct obstack *h, void *obj)
+{
+  struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
+  struct _obstack_chunk *plp;	/* point to previous chunk if any */
+
+  lp = h->chunk;
+  /* We use >= because there cannot be an object at the beginning of a chunk.
+     But there can be an empty object at that address
+     at the end of another chunk.  */
+  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))
+    {
+      plp = lp->prev;
+      CALL_FREEFUN (h, lp);
+      lp = plp;
+      /* If we switch chunks, we can't tell whether the new current
+	 chunk contains an empty object, so assume that it may.  */
+      h->maybe_empty_object = 1;
+    }
+  if (lp)
+    {
+      h->object_base = h->next_free = (char *) (obj);
+      h->chunk_limit = lp->limit;
+      h->chunk = lp;
+    }
+  else if (obj != 0)
+    /* obj is not in any of the chunks! */
+    abort ();
+}
+
 # ifdef _LIBC
 /* Older versions of libc used a function _obstack_free intended to be
    called by non-GCC compilers.  */
